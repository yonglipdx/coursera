 A Tutorial of C++ by Barne Stroustrup.

*** The basic
   1. C++ is statical language. Compiler has to know all variable type when in compile/run? time.
	2. A non-zero return value from main() indicates a failure.
		If no value returned, the system will receive a value indicating successfully completion. 
      Not every system and execution environment make use of return value.
	3. A function declariation may contains arguments which is helpful for reading. 
		The compiler will simply ignore the argument unless the declaration is also a function definition.
	4. For class member function, the name of the class is also part of the function type ---> ?????
	5. Scope and life time
		local scope, class scope, namespace scope, 
      for a namespace object, the point of destruction is the end of the program.
		a object created by "new" "lives" until destroyed by "delete"
	6. constexpr: evaluated at compile time.
      ----> ?????? We allow a constexpr function to be called with non-constant-expression arguments
      in contexts that do not require constant expressions, so that we don’t have to define essentially
      the same function twice: once for constant expressions and once for variables
	7. int v[] = {0,1,2,3,4};
		for (auto a :v) count << v[a];
	8. Prefer the {}-initializer syntax for declarations with a named type;
      Prefer the = syntax for the initialization in declarations using auto
	9. Use nullptr rather than 0 or NULL

*** User defined Types
	1. A struct is simply a class with its members public by default.

*** Modularity
	1. C++ offers namespaces as a mechanism for expressing that some declaration belong together and their 
		names should clash with other names.
	2. void user(int sz) noexcept ---> A function should never thrown an exception can be declared "noexcept".
		if all good intend and handling fails, so that the function still throws, the standard library function
		"terminate" is called immediately. 
	3. Often, a function has no way of completing its assigned task after an exception is thrown. 
		"handling" exception simply means doming some minimal local cleanup and rethrowning.
      when "new" cant find memory to allocate, std::bad_alloc is thrown.
	4. static_assert<A,S> prints S as compiler error message if A is not true
	5. Avoid non-inline function definition in headers.
	6. let constructor establish an invariant, and throw if it cannot ------>???????
	7. design error-handling strategy around invariants. ------>??????

*** Class
	1. RAII: Resource Acquisition Is Initialization. -> Avoid naked "new" and "delete"
	2. <static_cast><int>(list.size()): static_cast does not check the value it is converting ---->??????
	   page: 39
	3. A container is an object holding a collection of elements, 
	4. dynamic_cast: "is kind of" and "is instance of" operation
	   if the object pointed to by the argument of dynmaic_cast is not of the expected type, nullptr returned. --> usually not failure
		when a different type is unacceptable, we can simple dynamic_cast to a reference type. If the object is not
		of the expected type, bad_cast is thrown.---> failure
	5. use unique_ptr to avoid naked pointer.
	6. && means rvlue reference and is reference to which can bind an rvalue.
		a move constructor doesnot take const argument, after all, a move constructor is supposed to remove the value from its argument. 
		a move operator is applied when an rvalue reference is used to an  initializer or as the right-hand side of an assignment.
		when the programmer knows that a value will not be used again, but the compiler cannot be smart enough to figure that out, 
		the programmer can be specific: y = std::move(x);
	7. Essential Operations
		Constructors, destructors, copy operation, move operations. 
		If a class X has a destuctor that performs a nontrivial task, such as free-store deallocation or lock release, the class is likely 
		to need the full complement of functions:
			X(Sometype);	// "ordinary constructor" create an object
			X(); 				// default constructor
			X(const X&)		// copy constructor
			X(const X&&)	// move constructor
			X& operator=(const X&) 	// conpy assignment: clean up target and copy
			X& operator=(X&&) 		// move assignment: clean up target and move
			~X() 				// destructor: clean up
         Except "ordinary constructor", these special member functions will be generated by the compiler as needed.
			to be explicit about generating default implementation:
	      Y(const Y&) = default;
         ***if you are explicit about some defaults, other default definitions will not be generated****

		There are five situations in which an object is copied or  moved:
			As the source of an assignment
			As an object initializer
			As a function argument
			As a function return type
			As an exception

		When a class has a pointer or a reference member, it is usually a good idea to be explicit about 
		copy of move operator. The reason is that a pointer or reference will point to something that the
		class needs to delete, in which the default copy would be wrong, or point to something that the
		class must not delete, in which case a reader of the code would like to know that.

		explicit Vector(int s) 	// non implicit conversion from int to vector
			--> Vector v1(7); 	//OK v1 has 7 elements
			--> Vector v2 = 7;	//Error, no implicit conversion from int to vector

	8. Resource management.
		std::vector<thread> my_threads;
		Vector init(int n)
		{
			thread t{heartbeat};
			my_threads.push_back(move(t));
			Vector vec(n)
			...
			return vec;
		}
		This makes resource handles, such as Vector and thread, an alternative to using pointers in many cases----?????

	9. Suppressing Operations
		Using the default copy or move for a class in a hierarchy is typically a disaster: given only a pointer to a base,
		we simply donnot know what members the derived class has, so we cannot know how to copy it.

		Shape(const Shape&)=delete 				// no copy operations
		Shape& operator=(const Shape&)=delete 

		Shape(Shape&&) = delete;					// no move operations
		Shape& operator=(Shape&&)= delete;		
		
      if user has explicitly declared a destructor, a move operation is not implicitly generated for a class.
		==delete mechanism is general, it can used to suppress any operation.

	10. Make a function a member only if needs direct access to the representation of a class.
	11. declare a member function const if it does not modify the state of its object.
	12. If a class is a container, give it an initializer-list constructor   ---->??????
	13. An abstract class typically doesnot need a constructor but a destructor which is virtual-------> ?????
	14. access polymorphic objects through pointers and references.
	15. A class with a virtual function should have a virtual destructor.
	16. A function in derived class overrides a virtual function in a base. to make it clear, explicitly overidding:
		void draw() const override; ---> tells that draw is virtual function in supperclass.
	17. return container by value (relying on move for efficiency)
	18. by default, declare single-argument constructor explicit.
	19. if a class is a resource handle, it needs a constructor, a destructor, and non-default copy operations.

*** Template
	1. In C++98, space is needed between two nested template > >
	2. Template are a compile-time mechanism, so their use incurs no run-time overhead compared to hand-crafted code.
	3. Template value argument is useful in many contexts 
			template<typename T, int N>
         struct Buffer{...}
         Buffer<char, 1024> glob // global buffer statically allocated			
         fuc(){
            Buffer<char, 1024> local // local buffer on the stack
         }
	4. Function Template
	5. Function Object(functor): define object that can be called like function.

		use operator()

	   	template<typename T>
			class Less_than {
				const T val; // value to compare against
				public:
				Less_than(const T& v) :val(v) { }
				bool operator()(const T& x) const { return x<val; } // call operator
         }


         // dummy usage
			Less_than<int> lti {42}; 
         Less_than<string> lts {"Backus"};

			void fct(int n, const string & s)
			{
				bool b1 = lti(n); // tr ue if n<42
				bool b2 = lts(s); // tr ue if s<"Backus"
         }

			//real usage, similar to std::sort()

	   	template<typename C, typename P> // P--> policy object, can be Less_than or others.
			int count(const C& c, P pred)  
			{
				int cnt = 0;
				for (const auto& x : c)
				if (pred(x))
				++cnt;
				return cnt;
			}

			count(vec,Less_than<int>{15}; --> #of elements in vec which less than 15.

	6. lambda expression
		There is notation for implicitly generating function objects;
		[&](int a){return a<x;}  ---->lambda expression.
      Had we wanted to "capture" only x, we could have said so [&x];
		Had we want to give the generated object a copy of x, we could have said so: [=x]
		capture nothing is [], 
		capture All local name used by value is [=]
		capture All local name used by reference is [&]
      Using lambdas can be convenient and terse, but also obscure. For nontrivial 
		actions(say, more than a simple expression), naming the operation so as to more
		clearly state its purpose and to make it reusable.
		
		Example: 

			--->without lambdas	

         void draw_all(){};
         void rotate_all(){};

         void user()
			{
				std::vector<Shape∗> v;
				while (cin)
				   v.push_back(read_shape(cin));
			   draw_all(v); //call draw() for each element
			   rotate_all(v,45); //call rotate(45) for each element
				for (auto p : v) // remember to delete elements
				   delete p;
         }

			--->with lambdas: get rid of draw_all/rotate_all
			template<typename C, typename Oper>
			void for_all(C& c, Oper op) // assume that C is a container of pointers
			{
			   for (auto& x : c)
			      op(*x); // pass op() a reference to each element pointed to
         }

         void user()
			{
				vector<unique_ptr<Shape>> v;
				while (cin)
			  	   v.push_back(read_shape(cin));
				for_all(v,[](Shape& s){ s.draw(); }); // draw_all()
				for_all(v,[](Shape& s){ s.rotate(45); }); // rotate_all(45)
			}

	7. Variddic Templates -> A template can be defiend to accept an arbitrary number of arguments of arbitrary types.
			template<typename T, typename ... Tail>
			void f(T head, Tail... tail)
			{
				g(head); // do something to head
				f(tail...); // tr y again with tail
         }
			The key is: 
				1. do sth for head first (real function g())
				1. recursively call f(Tail). 
			variadic templates are widely used in the stardard library.

	8. Aliases
		---> Every stardard-library container provides value_type as the name of its value type. 
		this allows us to write code that will work for every container that follows this
		convention. 

		template<typename C>
		using Element_type = typename C::value_type; // the type of C’s elements
		template<typename Container>
		void algo(Container& c)
		{
			Vector<Element_type<Container>> vec; // keep results here
	   	// ...
      }
			
		--->Aliasing mechanism can be used to define a new template by binding some or all template argument.
		template<typename Key, typename Value>
		class Map {
		   // ...
		};

		template<typename Value>
		using String_map = Map<string,Value>;
		String_map<int> m; // m is a Map<str ing,int>

	9. Template Compilation Model --->?????
		The type checking provided for templates checks the use of arguments in the template definition
		rather than against an explicit interface (in a template declaration). This provides a compile-time
		variant of what is often called duck typing (‘‘If it walks like a duck and it quacks like a duck, it’s a
		duck’’). Or – using more technical terminology – we operate on values, and the presence and
		meaning of an operation depend solely on its operand values. This differs from the alternative view
		that objects have types, which determine the presence and meaning of operations. Values ‘‘live’’ in
		objects. This is the way objects (e.g., variables) work in C++, and only values that meet an object’s
		requirements can be put into it. What is done at compile time using templates does not involve
		objects, only values.
		The practical effect of this is that to use a template, its definition (not just its declaration) must
		be in scope. For example, the standard header <vector> holds the definition of vector. An unfortunate
		side effect is that a type error can be found uncomfortably late in the compilation process and
		can yield spectacularly bad error messages because the compiler found the problem by combining
		information from several places in the program.

	10. Use template to express algorithms that apply to many argument
	11. Use template to express containers
	12. Template are type-safe, but checking happens too late.
	13. Use "concept" as a design tool -----> ????
	14. Use function object as arguments to algorithm
	15. Use lambda if you need a simple function object in one place only.
	16. There is no separate compilation of templates.: #include template definitions in every translation unit that uses them.
			
*** Library Overview
	1. array, bitset, and tuple are special-purpose containers. they are container.
	2. standard-library are defined in namespace std;

*** String and Regular Expression
	1. The stardard string has a move constructor so retuning even long strings by value is efficient.
	2. String is mutable.
	3. String can be compared
	4. c_str() to get a read-only C-style string(a zero-terminated array of char)
	5. A user can define strings of arbitrary character types. 
		using Jstring = basic_string<Jchar> -->assume we have a Japanese character type Jchar
	6. REGULAR EXPRESSION
		.....
	7. Use at() other than iterators or [] for range checking
	8. Use iterators and [] rather than at() to optimize speed.
	9. use a string_stream or a generic value extraction function (such as to<x>) for numberic conversion
	10. A basic string can be used to make strings of characters of any type.
	11. use regex for most conventional uses of regular expressions
	12. use regex_match() to match a complete input
	13. USe regex_search() to search for a pattern in a input stream.
	14. Uaw regex_iterators for iterating over a stream looking for a pattern

*** I/O stream
	1. The I/O stream library provides formatted and unformatted buffered I/O of text and numeric values.
	4. The operations on istream and ostreams are type-safe, type-sensitive and extensible to handle user-defined types.

	5. Output (ostream)
	   ostream --> converts typed objects to a stream of characters(bytes). can be chained.
		<ostream>, I/O stream defines output for every build-in type. Further, it is easy to defined output of a user-defined type.
	   << (put to) is used as an output operator on object of type ostream, such as cout(standard output stream) and
	   cerr (standard error stream). By default values written to cout are converted to a sequence of characters. 

	6. Input (istream)
	   istream --> converts a stream of characters (bytes) to typed objects. can be chained.
		>> ("get from") is used for input operator.
		string str; cin >> str.
		By default, a whitespace character, such as space or newline, terminates the read. 
		Use getline(0 to read a whole line. 
		string str; getline(cin, str);

	7. I/O state (iostream)
		An iostream has a state that we can e examine to determine whether an operation succeeded.
		In general, the I/O state holds all the info needed to read or write, such as formatting info,
		error state(eg. end-of-input been reached), and what kind of buffer is used. User can set the 
		state to reflect that an error has occurred and clear the state if an error was not serious. 
	
	8. I/O of user-defined Types

		struct Entry {
		  string name;
		  int number;
		};		

		// easy for output
		ostream& operator<<(ostream& os, const Entry& e)
		{
			return os << "{\"" << e.name << "\", " << e.number << "}";
		}
		
		//complicate for input
		istream& operator>>(istream& is, Entry& e){
	      ...	
		}

	9. Formatting
		output integers as decimal(defaul), octal, hexadecimal..
		cout << 1234 << ',' << hex << 1234 << ',' << oct << 1234 << '\n'; // pr int 1234,4d2,2322
		Precison: determine the number of digits used to display a floating-point number.
		general foramt/scientific/fixed format. 
     	cout.precision(8);
	   cout << 1234.56789 << ' ' << 1234.56789 << ' ' << 123456 << '\n';
	   cout.precision(4);
	   cout << 1234.56789 << ' ' << 1234.56789 << ' ' << 123456 << '\n';
	     This produces:
				 1234.5679 1234.5679 123456
				 1235 1235 123456

	10. File Stream <fstream>
		ifstreasm -> reading from file
		ofstream -> writing to file
		fstream for reading and writing to a file.
		
		ofsteam ofs("target");  //ofs for output
		if (!ofs)
			error("couldn't open 'targe' for writing");
		ofs can be sued as an ordinary ostream(jsut like cout)

		fstream ifs;	// "i" for "input"
		if(!ifs)
			error("couldnot open 'source' for reading");
		ifs can be sued as an ordinary istream just like cin
	
	11. stringstream <sstream>
		istringstream for reading from a string
		ostringstream for writing to a string
		stringstream for reading and writing to a string
		
	12. Tips
		define << and >> for user-defined types with values that have meaningful textual representation.
		there are iostream for ordinary characters and wide characters, and you can define an iostream
		for any kind of character.
		
	13. Binary I/O is supported.
	14. Chain <<, >> operators for a terser notation. 
	15. By default >> skip initial whitespace.
	16. Donot try to copy a file stream
	17. Remember to check that a file stream is attached to a file before using it.
	18. user stringstream for in-memory formatting
	
*** Container
	1. A class with the main purpose of holding objects is commonly called container.

	2. vector: use it as default container. 
		A vector is a sequence of elements of a given type. The elements are stored contiguously in memory.
		The standard-library vector has members capacity(), push_back(), reserve()..
		If you have a class hierarchy that relies on virtual functions to get polymorphic behavior, 
		do not store objects directly in a container. Instead store a pointer (or a smart pointer).
					 vector<Shape> vs; // No, don¡¯t - there is no room for a Circle or a Smiley
					 vector<Shape.>vps; //better, but see ¡×4.5.4
					 vector<unique_ptr<Shape>> vups; // OK

		Standard-library vector does not guarantee range checking. 
		  void silly(vector<Entry>& book)
		  {
			  // no error reported. i will receive some random value !!!!
		     int i = book[book.size()].number; // book.size() is out of range
		     // ...
        }

		  A simple range check Vec on top of standard vector.
			
					 template<typename T>
					 class Vec : public std::vector<T> {
						public:
							using vector<T>::vector; // use the constructors from vector (under the name Vec)
							T& operator[](int i) // range check
							{ return vector<T>::at(i); }
							const T& operator[](int i) const // range check const objects; §4.2.1
							{ return vector<T>::at(i); }
					 };


	3. List: a double-linked list:   
   3.5 forward_list: single-linked list.
	4. map: a balanced binary tree (red-black tree). nlgn. searching.
	5. unordered_map: hash container
   6. 
	     vector<T> A variable-size vector (§9.2)
		  list<T> A doubly-linked list (§9.3)
		  forward_list<T> A singly-linked list
		  deque<T> A double-ended queue
		  set<T> A set (a map with just a key and no value)
		  multiset<T> A set in which a value can occur many times
		  map<K,V> An associative array (§9.4)
		  multimap<K,V> A map in which a key can occur many times
		  unordered_map<K,V> A map using a hashed lookup (§9.5)
		  unordered_multimap<K,V> A multimap using a hashed lookup
		  unordered_set<T> A set using a hashed lookup
		  unordered_multiset<T> A multiset using a hashed lookup
		  array<T,N> fixed-size array
		  bitset<N>. 
	7. basic operator for all container: begin(), end(), size(), 
	8. push_back() can be used for vector, list, and others.
   9. use reserve() to avoid invalidating pointers and iterators to elements.
	10. use push_back(), resize() on a container rather than realloc() on an array	
	11. Element are copied into a container.
	12. pass a container by reference and return a container by value.
	13. for a container, use ()-initializer syntax for sizes and {}-initializer syntax for list of elements.
	14. A list is relatively expensive to traverse.
	15. use unordered containers for fast lookup in large a amounts of data
	16. use ordered containers (eg. map, set) if need to iterate over their elements in order.
	17 hash function obtained by combining standard hash functions for elements using exclusive or are often good.


# VI
   set spell spelllang=en_us
   set syntax=c++/java/latex/python...
   set tabstop=3 softtabstop=0 noexpandtab shiftwidth=3
   

#change git default editor:
	Add gvim path to system PATH (e.g C:\Programs Files (x86)\Vim\vim74
	git config --global core.editor [to_gvim_path_without_exe]

#change gvim background color: 
	In .vimrc
   	colorscheme koehler

# Make gvim compatible with Chinese character
	In .vimrc:
   	set encodding=utF8
   	set guifontwide=NSimSun

# to solve conflict issue simpliar to sync/commit in perforce.
# git stash
# git pull
# git stash pop
#  resolve conflict if any
#  git push origin master

# syntax highlight in gvim
        set syntax=cpp
        set syntax=lex
 
# Lex
	Scanner produces a stream of tokens from the input source.
	lex is a scanner generator.
	lex input is set of regular expressions and associated action (wirtten in C)
	lex output is a table-driven scanner (lex.yy.c)
	flex: an open source implementation of lex.

	# lex input
		first part (optional)
		table size demision
		defination of text replacement
		global C code (specail syntax required)
		...
		%% -----> termination of FIRST PART
		pattern	action
		regular expression and action
		action and be C statment or block of C code.
		...
	 	%% ------> termination of SECOND PARt
		Third PART (optional)
		C code simplied used as is.

	Example: filename: exl.l
	--------
	%%
	"hello world"	printf("goodbye\n");
	.		;  ----> ignore everthing other than "hello world"
	%%
	--------

	lex exl.1 ----> generate a scanner, saved as lex.yy.c
	cc lex.yy.c -ll  (with -ll option main() is grab from the lex library)


	Example2: suppose we have configuration file "config.in"
	--------

# yacc



# char* const vs    const char*
	according to the standard, const modifies the element directly to its left. 
	The use of const at the beginning of a declaration is just a convenient mental shortcut. 
	So the following two statements are equivalent:
	char const * pointerToConstantContent1;
	const char * pointerToConstantContent2;

	In order to ensure the pointer itself is not modified, 
	const should be placed after the asterisk:
	char * const constantPointerToMutableContent;

	To protect both the pointer and the content to which it points, use two consts.
        char const * const constantPointerToConstantContent;
	
	

# stringstream:
	example1: 
	  string a("123");
          stringstream ss(a);
	  ss << "456"
	  cout << aa.str(); ---> 456

        example2:
	  string a("123");
          stringstream ss("");
	  ss << a << << "456"
	  cout << aa.str(); ---> 123456

# ssize_t size_t

        to avoid i == -1

        size_t i: 
                 if (i > -1) // not OK since i always > -1
                 use i< (size_t)-1  to make sure i > -1;

        ssize_t i: 
		 i > -1 is OK since i could be -1 in ssize_t




