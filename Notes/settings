 A Tutorial of C++ by Barne Stroustrup.

*** The basic
   1. C++ is statical language. Compiler has to know all variable type when in compile/run? time.
	2. A non-zero return value from main() indicates a failure.
		If no value returned, the system will receive a value indicating successfully completion. 
      Not every system and execution environment make use of return value.
	3. A function declariation may contains arguments which is helpful for reading. 
		The compiler will simply ignore the argument unless the declaration is also a function definition.
	4. For class member function, the name of the class is also part of the function type ---> ?????
	5. Scope and life time
		local scope, class scope, namespace scope, 
      for a namespace object, the point of destruction is the end of the program.
		a object created by "new" "lives" until destroyed by "delete"
	6. constexpr: evaluated at compile time.
      ----> ?????? We allow a constexpr function to be called with non-constant-expression arguments
      in contexts that do not require constant expressions, so that we donâ€™t have to define essentially
      the same function twice: once for constant expressions and once for variables
	7. int v[] = {0,1,2,3,4};
		for (auto a :v) count << v[a];
	8. Prefer the {}-initializer syntax for declarations with a named type;
      Prefer the = syntax for the initialization in declarations using auto
	9. Use nullptr rather than 0 or NULL

*** User defined Types
	1. A struct is simply a class with its members public by default.

*** Modularity
	1. C++ offers namespaces as a mechanism for expressing that some declaration belong together and their 
		names should clash with other names.
	2. void user(int sz) noexcept ---> A function should never thrown an exception can be declared "noexcept".
		if all good intend and handling fails, so that the function still throws, the standard library function
		"terminate" is called immediately. 
	3. Often, a function has no way of completing its assigned task after an exception is thrown. 
		"handling" exception simply means doming some minimal local cleanup and rethrowning.
      when "new" cant find memory to allocate, std::bad_alloc is thrown.
	4. static_assert<A,S> prints S as compiler error message if A is not true
	5. Avoid non-inline function definition in headers.
	6. let constructor establish an invariant, and throw if it cannot ------>???????
	7. design error-handling strategy around invariants. ------>??????

*** Class
	1. RAII: Resource Acquisition Is Initialization. -> Avoid naked "new" and "delete"
	2. <static_cast><int>(list.size()): static_cast does not check the value it is converting ---->??????
	   page: 39
	3. A container is an object holding a collection of elements, 
	4. dynamic_cast: "is kind of" and "is instance of" operation
	   if the object pointed to by the argument of dynmaic_cast is not of the expected type, nullptr returned. --> usually not failure
		when a different type is unacceptable, we can simple dynamic_cast to a reference type. If the object is not
		of the expected type, bad_cast is thrown.---> failure
	5. use unique_ptr to avoid naked pointer.
	6. && means rvlue reference and is reference to which can bind an rvalue.
		a move constructor doesnot take const argument, after all, a move constructor is supposed to remove the value from its argument. 
		a move operator is applied when an rvalue reference is used to an  initializer or as the right-hand side of an assignment.
		when the programmer knows that a value will not be used again, but the compiler cannot be smart enough to figure that out, 
		the programmer can be specific: y = std::move(x);
	7. Essential Operations
		Constructors, destructors, copy operation, move operations. 
		If a class X has a destuctor that performs a nontrivial task, such as free-store deallocation or lock release, the class is likely 
		to need the full complement of functions:
			X(Sometype);	// "ordinary constructor" create an object
			X(); 				// default constructor
			X(const X&)		// copy constructor
			X(const X&&)	// move constructor
			X& operator=(const X&) 	// conpy assignment: clean up target and copy
			X& operator=(X&&) 		// move assignment: clean up target and move
			~X() 				// destructor: clean up
         Except "ordinary constructor", these special member functions will be generated by the compiler as needed.
			to be explicit about generating default implementation:
	      Y(const Y&) = default;
         ***if you are explicit about some defaults, other default definitions will not be generated****

		There are five situations in which an object is copied or  moved:
			As the source of an assignment
			As an object initializer
			As a function argument
			As a function return type
			As an exception

		When a class has a pointer or a reference member, it is usually a good idea to be explicit about 
		copy of move operator. The reason is that a pointer or reference will point to something that the
		class needs to delete, in which the default copy would be wrong, or point to something that the
		class must not delete, in which case a reader of the code would like to know that.

		explicit Vector(int s) 	// non implicit conversion from int to vector
			--> Vector v1(7); 	//OK v1 has 7 elements
			--> Vector v2 = 7;	//Error, no implicit conversion from int to vector

	8. Resource management.
		std::vector<thread> my_threads;
		Vector init(int n)
		{
			thread t{heartbeat};
			my_threads.push_back(move(t));
			Vector vec(n)
			...
			return vec;
		}
		This makes resource handles, such as Vector and thread, an alternative to using pointers in many cases----?????

	9. Suppressing Operations
		Using the default copy or move for a class in a hierarchy is typically a disaster: given only a pointer to a base,
		we simply donnot know what members the derived class has, so we cannot know how to copy it.

		Shape(const Shape&)=delete 				// no copy operations
		Shape& operator=(const Shape&)=delete 

		Shape(Shape&&) = delete;					// no move operations
		Shape& operator=(Shape&&)= delete;		
		
      if user has explicitly declared a destructor, a move operation is not implicitly generated for a class.
		==delete mechanism is general, it can used to suppress any operation.

	10. Make a function a member only if needs direct access to the representation of a class.
	11. declare a member function const if it does not modify the state of its object.
	12. If a class is a container, give it an initializer-list constructor   ---->??????
	13. An abstract class typically doesnot need a constructor but a destructor which is virtual-------> ?????
	14. access polymorphic objects through pointers and references.
	15. A class with a virtual function should have a virtual destructor.
	16. A function in derived class overrides a virtual function in a base. to make it clear, explicitly overidding:
		void draw() const override; ---> tells that draw is virtual function in supperclass.
	17. return container by value (relying on move for efficiency)
	18. by default, declare single-argument constructor explicit.
	19. if a class is a resource handle, it needs a constructor, a destructor, and non-default copy operations.


# VI
   set spell spelllang=en_us
   set syntax=c++/java/latex/python...
   set tabstop=3 softtabstop=0 noexpandtab shiftwidth=3
   

#change git default editor:
	Add gvim path to system PATH (e.g C:\Programs Files (x86)\Vim\vim74
	git config --global core.editor [to_gvim_path_without_exe]

#change gvim background color: 
	In .vimrc
   	colorscheme koehler

# Make gvim compatible with Chinese character
	In .vimrc:
   	set encodding=utF8
   	set guifontwide=NSimSun

# to solve conflict issue simpliar to sync/commit in perforce.
# git stash
# git pull
# git stash pop
#  resolve conflict if any
#  git push origin master

# syntax highlight in gvim
        set syntax=cpp
        set syntax=lex
 
# Lex
	Scanner produces a stream of tokens from the input source.
	lex is a scanner generator.
	lex input is set of regular expressions and associated action (wirtten in C)
	lex output is a table-driven scanner (lex.yy.c)
	flex: an open source implementation of lex.

	# lex input
		first part (optional)
		table size demision
		defination of text replacement
		global C code (specail syntax required)
		...
		%% -----> termination of FIRST PART
		pattern	action
		regular expression and action
		action and be C statment or block of C code.
		...
	 	%% ------> termination of SECOND PARt
		Third PART (optional)
		C code simplied used as is.

	Example: filename: exl.l
	--------
	%%
	"hello world"	printf("goodbye\n");
	.		;  ----> ignore everthing other than "hello world"
	%%
	--------

	lex exl.1 ----> generate a scanner, saved as lex.yy.c
	cc lex.yy.c -ll  (with -ll option main() is grab from the lex library)


	Example2: suppose we have configuration file "config.in"
	--------

# yacc



# char* const vs    const char*
	according to the standard, const modifies the element directly to its left. 
	The use of const at the beginning of a declaration is just a convenient mental shortcut. 
	So the following two statements are equivalent:
	char const * pointerToConstantContent1;
	const char * pointerToConstantContent2;

	In order to ensure the pointer itself is not modified, 
	const should be placed after the asterisk:
	char * const constantPointerToMutableContent;

	To protect both the pointer and the content to which it points, use two consts.
        char const * const constantPointerToConstantContent;
	
	

# stringstream:
	example1: 
	  string a("123");
          stringstream ss(a);
	  ss << "456"
	  cout << aa.str(); ---> 456

        example2:
	  string a("123");
          stringstream ss("");
	  ss << a << << "456"
	  cout << aa.str(); ---> 123456

# ssize_t size_t

        to avoid i == -1

        size_t i: 
                 if (i > -1) // not OK since i always > -1
                 use i< (size_t)-1  to make sure i > -1;

        ssize_t i: 
		 i > -1 is OK since i could be -1 in ssize_t



	
